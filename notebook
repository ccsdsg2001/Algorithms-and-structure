数据结构和算法
程序=数据结构+算法。数据结构是算法的基础。
数据结构：线性结构和非线性结构。线性结构：最常用的数据结构，特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表成为顺序表，其存储元素是连续的。链式存储的线性表为链表。其存储元素不一定连续。
线性结构常见的有：数组，队列，链表和栈。

稀疏数组
很多没有意义的数组——稀疏数组
处理方法是：记录数组一共有几行几列，有多少个不同的值。把具有不同值的元素的行列和值记录在一个小规模的数组中，从而缩小程序的规模。
二维数组 转 稀疏数组的思路
1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组
稀疏数组转原始的二维数组的思路
1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

队列
队列是一个有序表，可以用数组或链表来实现
遵循先入先出的原则，先存入队列的数据，要先取出，后存入的要后取出
数组模拟队列。队列本事是有序表，用maxsize表示该队列最大容量。因为队列的输出，输入分别是从前后端来处理，需要两个表量front和rear分别记录队列前后端的下标，front随着数据输出而改变。而rear随着数据输入而改变
思路分析：当我们将数据存入队列称”addqueue“,需要两个步骤
1：将尾指针往后移：rear+1，当front==rear【空】
2：若尾指针rear小于队列最大小标maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxsize-1【队列满】
问题分析：数组使用一次就不能使用，没有达到复用的效果。2.将这个数组使用算法，改进成一个环形数组
数组模拟环形队列
为充分利用数组，将数组看作一个环形（通过取模方式来实现）
分析说明：1尾索引的下一个头为索引时表示队列满，即将队列容量空出一个，在做判断队列满时候注意（rear+1）%maxsize==front满。2.rear ==front[空]
思路：1 front变量的含义调整：front指向队列中的第一个元素，arr[front]就是队列的第一个元素front初始值=0.
2.rear指向队列的最后一个元素的后一个位置，空出一个空间作为约定，rear初始值=0
3.当队列满时，（rear+1）%maxsize=front【满】
4.队列为空的条件，rear==front(空)
5.队列中有效的数据个数(rear+maxsize-front)%maxsize //rear =1 front =0。可以在原来基础上修改得到一个环形队列

链表
1.链表是有序的列表，链表以节点的方式来存储，是链式存储。2.每个节点包含data域，next域：指向下一个节点。3.链表的各个节点不一定是连续存储。4.链表分带头节点的链表和没有头节点的链表
，根据需求来确定
思路分析：添加（创建）1.先创建一个head头节点，作用就是表示单链表的头。2.后面我们每添加一个节点，直接加入到链表的最后。遍历：1.通过一个辅助变量去遍历，帮助遍历整个链表
如需要按照编号的顺序添加，思路：1首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定。2.新的节点.next=temp.next 3.将temp.next= 新的节点
3.修改节点功能：（1）先找到该节点，通过遍历（2）temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname
4.删除节点 （1）先找到需要删除这个节点的前一个节点temp。（2）temp.next =temp.next.next (3)被删除节点不会有其他引向，被垃圾回收机制回收
求单链表中有效节点的个数
/*方法：找到单链表节点的个数
* head 链表的头节点
* return 返回的就是有效节点的个数*/
查找单链表中的倒数第K个节点
/*思路
* 1.编写一个方法，接受head节点，同时接受一个index
* 2.index表示是倒数第index个节点
* 3.先从链表从头到尾遍历，得到链表总长度getlength
* 4.得到size后，从链表中第一个开始遍历(size-index)个，就可以得到
* 5.如找到就返回节点，否则就返回null*/
单链表的反转
思路：1.先定义一个节点reverserhead =new Heronode（）
    * 2.从头遍历到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reversehead的最前端
    * 3原来的链表head.next =reverseHead.next*/
从头到尾打印单链表
思路分析：1.逆序打印单链表。2、方式1：先将单链表进行反转操作，然后在遍历，缺点就是会破坏原来单链表结构，不建议。方法2：可以利用栈的数据结构，将各个节点压入栈中，利用栈的先进先出的特点，实现逆序打印的结果

双向链表分析
单向链表的缺点分析：
1).单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。2).单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除，单链表删除节点时，需要temp，temp总是删除节点的前一个节点
思路分析：1）遍历：和单链表一样，只是可以向前，也可以向后查找。2）.添加：默认添加到双向链表的最后，（1）先找到双向链表的最后节点。（2）temp.next = newHeroNode (3)newHeroNode.pre = temp;
3).修改：思路和单向链表一样。4）.删除：(1)因为是双向链表，可以实现自我删除某个节点。（2）直接找到要删除节点如temp（3）temp.pre.next = temp.next (4)temp.next.pre =temp.pre;

单向环形链表
Josephu约瑟夫问题：设编号为1，2，~~~n的n个人围坐一圈，约定编号为K的人从1开始报数，数到M的那个人出列，他的下一位又从1开始报数，数到m的那个人有出列，直到所有人出列为止，从而产生一个出队编号的序列
提示：用一个不带头节点的循环链表来处理约瑟夫问题：先构成一个由N个节点的单循环链表，由K结点从1开始计数，计到M时，对应节点从链表中删除，在从被删除节点的下一个节点从1开始计数，直到最后一个节点从链表中删除算法结束
创建环形链表思路：构建一个单向的环形链表：（1）先创建第一个节点，让first指向该节点，并形成环形。（2）后面当我们创建一个新的节点，把节点加入到已有的环形链表即可
遍历环形链表：1.先让一个辅助指针（变量）curBoy，指向first节点。2.通过一个whule循环遍历环形链表即可curBoy.next== first 即可
环形链表出队列思路分析:1.需要创建一个辅助指针（变量）helper，事先指向环形链表的最后这个节点。2，先让first和helper移动k-1次，然后让first和helper指针同时移动m-1次。3.将first指向节点出列，first=first.next,helper.next=first.原来
first指向的节点没有任何引用，就会被回收。









































