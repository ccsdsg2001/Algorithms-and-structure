数据结构和算法
程序=数据结构+算法。数据结构是算法的基础。
数据结构：线性结构和非线性结构。线性结构：最常用的数据结构，特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表成为顺序表，其存储元素是连续的。链式存储的线性表为链表。其存储元素不一定连续。
线性结构常见的有：数组，队列，链表和栈。

稀疏数组
很多没有意义的数组——稀疏数组
处理方法是：记录数组一共有几行几列，有多少个不同的值。把具有不同值的元素的行列和值记录在一个小规模的数组中，从而缩小程序的规模。
二维数组 转 稀疏数组的思路
1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组
稀疏数组转原始的二维数组的思路
1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

队列
队列是一个有序表，可以用数组或链表来实现
遵循先入先出的原则，先存入队列的数据，要先取出，后存入的要后取出
数组模拟队列。队列本事是有序表，用maxsize表示该队列最大容量。因为队列的输出，输入分别是从前后端来处理，需要两个表量front和rear分别记录队列前后端的下标，front随着数据输出而改变。而rear随着数据输入而改变
思路分析：当我们将数据存入队列称”addqueue“,需要两个步骤
1：将尾指针往后移：rear+1，当front==rear【空】
2：若尾指针rear小于队列最大小标maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxsize-1【队列满】
问题分析：数组使用一次就不能使用，没有达到复用的效果。2.将这个数组使用算法，改进成一个环形数组
数组模拟环形队列
为充分利用数组，将数组看作一个环形（通过取模方式来实现）
分析说明：1尾索引的下一个头为索引时表示队列满，即将队列容量空出一个，在做判断队列满时候注意（rear+1）%maxsize==front满。2.rear ==front[空]
思路：1 front变量的含义调整：front指向队列中的第一个元素，arr[front]就是队列的第一个元素front初始值=0.
2.rear指向队列的最后一个元素的后一个位置，空出一个空间作为约定，rear初始值=0
3.当队列满时，（rear+1）%maxsize=front【满】
4.队列为空的条件，rear==front(空)
5.队列中有效的数据个数(rear+maxsize-front)%maxsize //rear =1 front =0。可以在原来基础上修改得到一个环形队列

链表
1.链表是有序的列表，链表以节点的方式来存储，是链式存储。2.每个节点包含data域，next域：指向下一个节点。3.链表的各个节点不一定是连续存储。4.链表分带头节点的链表和没有头节点的链表
，根据需求来确定
思路分析：添加（创建）1.先创建一个head头节点，作用就是表示单链表的头。2.后面我们每添加一个节点，直接加入到链表的最后。遍历：1.通过一个辅助变量去遍历，帮助遍历整个链表
如需要按照编号的顺序添加，思路：1首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定。2.新的节点.next=temp.next 3.将temp.next= 新的节点
3.修改节点功能：（1）先找到该节点，通过遍历（2）temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname
4.删除节点 （1）先找到需要删除这个节点的前一个节点temp。（2）temp.next =temp.next.next (3)被删除节点不会有其他引向，被垃圾回收机制回收
求单链表中有效节点的个数
/*方法：找到单链表节点的个数
* head 链表的头节点
* return 返回的就是有效节点的个数*/
查找单链表中的倒数第K个节点
/*思路
* 1.编写一个方法，接受head节点，同时接受一个index
* 2.index表示是倒数第index个节点
* 3.先从链表从头到尾遍历，得到链表总长度getlength
* 4.得到size后，从链表中第一个开始遍历(size-index)个，就可以得到
* 5.如找到就返回节点，否则就返回null*/
单链表的反转
思路：1.先定义一个节点reverserhead =new Heronode（）
    * 2.从头遍历到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reversehead的最前端
    * 3原来的链表head.next =reverseHead.next*/
从头到尾打印单链表
思路分析：1.逆序打印单链表。2、方式1：先将单链表进行反转操作，然后在遍历，缺点就是会破坏原来单链表结构，不建议。方法2：可以利用栈的数据结构，将各个节点压入栈中，利用栈的先进先出的特点，实现逆序打印的结果

双向链表分析
单向链表的缺点分析：
1).单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。2).单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除，单链表删除节点时，需要temp，temp总是删除节点的前一个节点
思路分析：1）遍历：和单链表一样，只是可以向前，也可以向后查找。2）.添加：默认添加到双向链表的最后，（1）先找到双向链表的最后节点。（2）temp.next = newHeroNode (3)newHeroNode.pre = temp;
3).修改：思路和单向链表一样。4）.删除：(1)因为是双向链表，可以实现自我删除某个节点。（2）直接找到要删除节点如temp（3）temp.pre.next = temp.next (4)temp.next.pre =temp.pre;

单向环形链表
Josephu约瑟夫问题：设编号为1，2，~~~n的n个人围坐一圈，约定编号为K的人从1开始报数，数到M的那个人出列，他的下一位又从1开始报数，数到m的那个人有出列，直到所有人出列为止，从而产生一个出队编号的序列
提示：用一个不带头节点的循环链表来处理约瑟夫问题：先构成一个由N个节点的单循环链表，由K结点从1开始计数，计到M时，对应节点从链表中删除，在从被删除节点的下一个节点从1开始计数，直到最后一个节点从链表中删除算法结束
创建环形链表思路：构建一个单向的环形链表：（1）先创建第一个节点，让first指向该节点，并形成环形。（2）后面当我们创建一个新的节点，把节点加入到已有的环形链表即可
遍历环形链表：1.先让一个辅助指针（变量）curBoy，指向first节点。2.通过一个whule循环遍历环形链表即可curBoy.next== first 即可
环形链表出队列思路分析:1.需要创建一个辅助指针（变量）helper，事先指向环形链表的最后这个节点。2，先让first和helper移动k-1次，然后让first和helper指针同时移动m-1次。3.将first指向节点出列，first=first.next,helper.next=first.原来
first指向的节点没有任何引用，就会被回收。

栈
栈是一个先入后出的有序列表。
栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表，允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底。
最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素相反，最后放入元素最先删除，最先放入元素最后删除。
栈的应用场景
1.子程序的调用:在跳往子程序前,将下个指令的地址存到堆栈中,直到子程序执行完再将地址取出,以回到原来程序中.
2.处理递归调用:存储下一个指令地址,将参数,区域变量等数据存入堆栈中.
3.表达式的转换(中缀表达式和后缀表达式)与求值
4.二叉树的遍历
5.图形的深度优先算法
实现栈的思路分析
1.使用数组来模拟栈
2.定义一个top来表示栈,初始化为-1
3.入栈的操作,当有数据加入到栈时,top++;stack[top] = data;
4.出栈的操作:int value =stack[top];top--;return value

栈实现综合计算器（中缀表达式）
使用栈完成表达式的计算思路
1.通过一个index值（索引），来遍历表达式
2.如发现是一个数字，则直接入数栈
3.如是一个符号，则：（1）如当前的符号栈为空，则直接入栈。（2）如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个数，在符号栈中pop出一个符号，进行运算，
将得到的结果，入数栈，将当前的操作符入符号栈，如果当前的操作符的优先级高于栈中的操作符，就直接入符号栈
4.当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
5.最后在数栈中只有一个数字，就是表达式的结果
前缀表达式
前缀表达式又称波兰式。前缀表达式的运算符位于操作数之前。
前缀表达式的求值
从右到左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈。重复上述过程直到表达式最左端，最后运算得出的值为表达式的结果
例如（3+4）*5-6对应前缀表达式是-*+3 4 5 6，步骤如下：
1.从右到左扫描，将6.5.4.3压入堆栈
2.遇到+运算符，弹出3和4，计算出3+4的值，得7，再将7入栈。
3.接下来*运算符，弹出7和5，计算7*5等于35，将35入栈
4.最后是-运算符，计算出35-6得值，由此得出最终结果
中缀表达式
中缀表达式就是常见的运算表达式。
后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后。
后缀表达式的计算机求值
从左到右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈。重复上述过程直到表达式的最右端，最后运算出结果就是表达式的结果
例：（3+4）*5-6对应的前缀表达式就似乎34+5*6—，步骤如下：
1 从左到右扫描，将3和4压入堆栈
2 遇到+运算符，弹出4和3，计算出3+4的值，得7，再将7入栈
3 将5入栈
4 接下来*运算符，弹出5和7，计算出7*5=35，将35入栈
5 将6入栈
6 最后-运算符，计算出35-6值，得出29最终结果
中缀表达式转换为后缀表达式
具体步骤：
1.初始化两个栈:运算符栈s1和存储中间的结果栈s2
2.从左到右扫描中缀表达式
3.遇到操作数时,将其压s2
4.遇到运算符时,比较与s1栈顶的运算符的优先级:(1)如果s1为空,或栈顶运算符为左括号"(",则直接将此运算符入栈.(2)否则,若优先级比栈顶运算符高,将运算符压入s1.(3)否则,将s1栈顶的运算符弹出并压入到s2中,再次转到(4-1)与s1中新的
栈顶运算符相比较
5.遇到括号时:1.如果是左括号"(",则直接压入到s1.(2)如果是右括号")",则依次弹出s1栈顶的运算符,并压入s2,直到遇到左括号位置,此时将这一对括号丢弃
6.重复步骤2到5,直到表达式的最右边.
7.将s1中剩余的运算符依次弹出并压入s2
8.依次弹出s2中的元素并输出,结果的逆序为中缀表达式对应的后缀表示式

递归
递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以使代码变得简洁
两个案例解释递归调用机制：打印问题，阶乘问题
递归解决什么问题:数学问题,各种算法中也会使用到递归,常用栈解决的问题.
递归时需要遵守的重要规则:
1.执行一个方法时,创建一个新的受保护的独立空间(栈空间)
2.方法的局部变量是独立的,不会相互影响,比如n变量
3.如果方法中使用的是引用类型变量,就会共享该引用类型的数据
4.递归必须向推出递归的条件逼近,否则就是无限递归,出现StackOverflowError
5.当一个方法执行完毕.或者遇到return,就会返回,遵守谁调用,就将结果返回给谁,同时当方法执行完毕或者返回时,该方法也执行完毕
递归—八皇后问题（回溯算法）
在8*8的国际象棋上摆放8个皇后，任意两个皇后不能处于同一行或同一列或同一斜线上，问有多少中摆法
问题算法思路分析
1.第一个皇后先放第一行第一列
2.第二个皇后放在第二行第一列，判断是否ok，如果不，继续放在第二列，第三列，依次把所有列放完，找到一个合适
3.继续第三个皇后，还是第一列，第二列~直到第8个皇后放在一个不冲突的为止，算找到了一个正确的解
4.当得到第一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到
5.然后回头继续第一个皇后放第二列，后面继续执行1，2，3，4的步骤
理论上应该创建二维数组来表示棋盘，但可以通过算法，用一个一维数组可解决问题。arr[8]={0，4，7，5，2，6，1，3}//对应arr下标,表示第几行,第几个皇后,arr[i]=val,val表示第i+1个皇后,放在第i+1行的第val+1列.

排序算法
排序也称排序算法，排序是将一组数据，以指定的顺序进行排列的过程。
排序的分类：1.内部排序：将需要处理的所有数据加载到内部存储器（内存）中进行排序。2.外部排序法:数据量过大,无法全部加载到内存中,需要借助外部存储(文件等)进行排序.3.常见排序算法分类:直接插入排序,希尔排序,简单选择排序,堆排序,冒泡排序,快速排序,归并排序,基数排序
算法时间复杂度
度量一个程序执行时间方法:1.事后统计方法:要在同一台计算机的相同状态下运行,才能比较那个算法速度更快.2.事前估算的方法:分析某个算法时间复杂度判断哪个算法更优
时间频度:一个算法花费的时间与算法中语句中执行的次数成比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n).
当n足够大时,可忽略常数项,忽略低次项,忽略系数
时间复杂度
1.一般情况下,算法中的基本操作语句的重复执行次数是问题规模n的某个系数,用T(n)表示,若有某个辅助函数f(n)使得n趋近于无穷大时,T(n)/f(n)的极限值不等于0的常熟,则称f(n)是T(n)的同数量级函数,记作T(n)=O(f(n)),称O(f(n))为算法的渐进时间复杂度,简称时间复杂度
2.T(n)不同,但时间复杂度可能相同
3.计算时间复杂度的方法:用常数1代替运行时间中的所有加法常数,修改后的运行次数函数中,只保留最高阶项,去掉最高阶项的系数
常见的时间复杂度
1.常数阶O(1) 2.对数阶O(log2n) 3.线性阶O(n) 4.线性对数阶O(nlog2n) 5.平方阶O(n^2) 6.立方阶O(n^3) 7.K次方阶O(n^K) 8.指数阶O(2^n)
Ps:常见的算法时间复杂度由小到大为O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(n^3)<O(n^K)<O(2^n),随着问题规模N的不断增大,时间复杂度不断增大,算法执行效率越低.避免使用指数阶的算法

1)常数阶O(1) 没有循环等复杂结构,时间复杂度就是O(1) ex:int i =1; int j =2; int m =i+j;上述代码再执行的时候,消耗的时候并不随着某个变量的增长而增长,用O(1)来表示它的时间复杂度
2)对数阶O(log2N) int i=1;while(i<n){i = i*2} 在循环里面,将I乘以2,之后I距离n就越来越近,假设循环x次之后,i就大于2,循环就退出了.时间复杂度为:O(log2n),O(log2n)的这个2时间上根据代码变化,i=i*3,则是O(log3n)
3)线性阶O(n)for(int i=1;i<=n;i++){j = i;j++} for循环里面的代码执行n遍,消耗的时间随着n的变化而变化的,可以用O(n)表示它的时间复杂度
4)线性对数阶O(nlogn) for(m=1;m<n;m++){i =1;while(i<n){i =i*2;}} 将时间复杂度O(logn)的代码循环N遍,时间复杂度就是N*O(logN)
5)平方阶O(n^2) for(x=1;i<=n;x++){for(x=1;i<=n;i++{j=i;j++}} 把O(n)代码嵌套循环一遍,时间复杂度就是O(n2),将其中一层循环n改成m,就是O(m*n)
平时时间复杂度和最坏时间复杂度
1)平均时间复杂度是所有可能的输入实例均以等概率出现的情况下,该算法的运行时间
2)最坏情况下的时间复杂度称最坏时间复杂度,一般时间复杂度是最坏情况下的时间复杂度,因为最坏情况下的时间复杂度是算法在如何输入实例上运行时间上的界限,保证了算法运行时间不会比最坏情况更长
3)平均时间复杂度和最坏时间复杂度;除shell排序和快排不一致,其他都一致
冒泡排序O(n^2) 交换排序O(n^2) 选择排序O(n^2) 插入排序O(n^2) 基数排序O(logR B) shell排序平均O(nlogN) 最差情形O(n^s) 1<s<2  快速排序O(nlogn) 最差O(n^2) 归并排序O(nlogn) 堆排序O(nlogn)
算法空间复杂度
一个算法的空间复杂度定义为该算法所耗费的存储空间.空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度,有的算法需要占用临时工作单元与解决问题规模n有关,随着n增大而增大,当n较大时,占用更多的存储单元.
从用户使用体验上看,更看重程序的执行速度,本质就是用空间换时间

冒泡排序
思路：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部。
优化：在排序过程中，各元素不断接近自己的位置，如一趟比较下俩没有进行过交换，说明序列有序，在排序过程中设置一个标志flag判断元素是否发生交换，从而减少不必呀的比较。
原始数组：{3，9，-1，10，20} 过程：1，一共进行数组的大小-1次大的循环。2. 每一样排序的次数在逐渐的减少。3.如在某趟排序中，没有发生一次交换，可以提前结束排序，这个就是优化.

选择排序
选择排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一种元素，再依规定交换位置后达到排序的目的。
选择排序思想：第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换,第二次从arr[1]-arr[n-1]中选取最小值,与arr[1]交换,第三次从arr[2]-arr[n-1]中选取最小值,与arr[2]交换,
第i次从arr[i-1]-arr[n-1]中选取最小值,与arr[i-1]交换,第n-1次从arr[n-2]-arr[n-1]中选取最小值,与arr[n-2]交换,总共通过n-1次,得到一个按排序码从小到大排列的有序序列
原始数组[101,34,119,1] 思路如下:1选择排序一共有数组大小-1轮排序.2每一轮排序,又是一个循环,循环的规则(1)先假定当前这个数是最小数(2)然后和后面每个数进行比较,如果发现有比当前数更小的数,就重写确定最小数,并得到下标.
(3)当遍历到数组的最后时,就得到本轮最小数和下标.(4)交换

插入排序
插入式排序属于内部排序法，是对于排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的
思路：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把他的排序码依次与有序表元素的排序码进行比较，将他插入到有序表中的适当位置，使之成为新的有序表

希尔排序
简单的插入排序存在的问题：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响
希尔排序是一种插入排序，他是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
基本思想：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件被分为一组，算法便终止
希尔排序有两种方法：1.交换法.2.移动法

快速排序
快速排序是对冒泡排序的一种改进，思路是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分中的所有数据比另外一部分所有数据都要小，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列

归并排序
归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治阶段将分的阶段得到各答案修补在一起，即分而治之

基数排序(桶排序)
基数排序属于分配式排序,又称桶子法,通过键值的各个位的值,将要排序的元素分配至某些桶中,达到排序的作用.
基数排序法属于稳定性的排序,基数排序法是效率高的稳定性排序法,基数排序是桶排序的拓展.实现原理:将整数按位数切割成不同的数字,然后按每个位数分别比较
基数排序基本思想:将所有待比较数值统一为同样的数位长度,数位较短的数前面补零.然后,从最低位开始,依次进行一次排序,从最低位排序一直到最高位排序完成以后,数列变成一个有序序列
第1轮排序:将每个元素的个位数取出,看这个数放在哪个对应的桶(一个一维数组).按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组)
第2轮排序:将每个元素的十位数取出,看这个数放在哪个对应的桶(一个一维数组).按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组)
第3轮排序:将每个元素的百位数取出,看这个数放在哪个对应的桶(一个一维数组).按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组)...依次实现
说明:1.基数排序是对桶排序的拓展,速度很快.2.基数排序是经典的空间换时间方式,占用内存很大,当对海量数据排序时,容易造成内存溢出.3.基数排序是稳定的
[假定在待排序的记录序列中国,存在多个具有相同的关键字的记录,记录的相对次序保持不变,即在原序列中,r[i]=r[j],且r[i]在r[j]之前,而在排序后的序列中
r[i]仍在r[j]之前,则称这种排序算法是稳定的,否则称为不稳定的].4,有负数的数组,不用基数排序来进行排序

查找算法
常见查找有四种：顺序(线性)查找,二分查找/折半查找,插值查找,斐波那契查找
二分查找算法
二分查找思路分析:1.首先确定该数组中间的下标mid = (left+right)/2 2.然后让需要查找的数findval和arr[mid]比较(1)findval >arr[mid] 说明你要查找的数在mid的右边,需要递归的向右查找.(2)findval<arr[mid] 你要查找的数在mid的左边,递归的向左查找.(3)findval==arr[mid]
说明找到就返回
什么需要结束递归:1找到就结束递归.2递归完整个数组,仍然没有找到findval,也需要结束递归,当left>right就需要退出

插值查找算法
原理：插值查找算法类似于二分查找,不同的是插值查找每次从自适应mid处开始查找
2.将折半查找中的求mid索引的公式,low表示左边索引left,high表示右边索引right,key就是findVal
3.int mid =low +(high-low)*(key -arr[low])/(arr[high] -arr[low]) ;/插值索引/   其对应为int mid =left+(right -left)*(findval-arr[left])/(arr[right -arr[left])
插值查找注意事项:1.对于数据量较大,关键字分布比较均匀的查找表来说,采用插值查找,速度较快.2.关键字分布不均匀的情况下,该方法不一定比折半查找要好.

斐波那契查找算法
数列中两个相邻的两个数比例无限接近0.618
原理:改变了中间节点mid的位置,mid不再是中间或插值得到,于黄金分割点附近,即mid=low+F(k-1)-1
对F(k-1)-1的理解:由斐波那契数列F[k] =f[k-1] +F[k-2]的性质,可以得到(F[k] -1) =(F[k-1]-1) +(F[k-2]-1)+1,该式说明:只要顺序表哦的长度为F[k]-1,则可以将表分成长度为F[k-1]-1和F[k-2]-1的两端,从而中间位置为mid=low+F(K-1)-1
2.类似的,每一字段也可以用相同的方式分割.3.但顺序表的长度n不一定刚好等于F[k]-1,这里长度k值只要使得F[k]-1恰好大于或等于n即可,由以下代码得,顺序表长度增加后,新增的位置(从n+1到F[k]-1位置),都为n位置的值即可.
while(n>fib(k)-1) k++;.

哈希表
散列表（Hash table，也叫哈希表），是根据关键码值（key value）而直接访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
题目：加入员工的信息，当输入员工的id时，要求查找该员工的所有信息。要求：不适用数据库，速度越快越好。

树
为什么需要树数据结构
数组存储方式的分析：
优点:通过下标方式访问元素,速度块,对于有序数组,还可以使用二分查找提高检索速度.
缺点:如果要检索具体某个值,或者插入值(按一定顺序)会整体移动,效率较低
链式存储方式的分析
优点:在一定程度上对数组存储方式有优化:比如插如一个数值节点,只需要将插入节点,链接到链表即可,删除效率也很好
缺点:在进行检索时,效率比较低,比如检索某个值,需要从头节点开始遍历
树存储方式分析
能提高数据存储,读取的效率,比如利用二叉排序树,既可以保证数据的检索速度,同时也可以保证数据的插入,删除,修改的速度

二叉树的概念
1.树有很多种,每个节点最多只能由两个子节点的一种形式称为二叉树.
2.二叉树的子节点分为左节点和右节点
3.如果该二叉树的所有叶子节点都在最后一层,并且节点层数=2^n-1,n为层数,则我们称为满二叉树
4.如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层叶子节点在右边连续,我们称为完全二叉树

二叉树遍历的说明
使用前序，中序和后序对二叉树进行遍历
1.前序遍历：先输出父结点，再遍历左子树和右子树
2.中序遍历：先遍历左子树，再输出父节点，再遍历右子树
3.后序遍历：先遍历左子树，再遍历右子树，最后输出父节点
总结：看输出父节点的顺序，就确定是前序，中序还是后序
思路分析及步骤：1.创建一个二叉树。2.前序遍历：（1）先输出当前节点（初始的时候是root节点）（2）如果左子节点不为空，则递归继续前序遍历。（3）如果右子节点不为空，则递归继续前序遍历
3.中序遍历：（1）如果当前节点的左子节点不为空，则递归中序遍历（2）输出当前节点（3）如果当前节点的右子节点不为空，则递归中序遍历
4.后序遍历（1）如果当前的左子节点不为空，则递归后序遍历（2）如果当前节点的右子节点不为空，则递归后序遍历（3）输出当前节点

二叉树查找指定节点
思路分析:前序查找思路(1)先判断当前节点的no是否等于要查找的(2)如果是相等,则返回当前节点(3)如果不等,则判断当前结点的左子结点是否为空,如果不为空,则递归前序查找(4)如果左递归前序查找,找到结点,则返回
,否则继续判断,当前的右子结点是否为空,如果不空,则继续向右递归前序查找
中序查找思路:1.判断当前结点的左子结点是否为空,如果不为空,则递归中序查找.2.如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前系欸但,否则继续进行右递归的中序查找.
3.如果右递归中序查找,找到就返回,否则就返回null
后序查找思路:.
1.判断当前结点的左子结点是否为空,如果不为空,则递归后序查找
2.如果找到,就返回,如果没有找到,就判断当前结点的右子结点是否为空,如果不为空,则右递归进行后序查找,如果找到就返回
3.和当前结点进行比较,如果是则返回,否则就返回null

二叉树删除结点
要求:如果删除结点是叶子结点,则删除该结点.如果删除的结点是非叶子结点,则删除该子树
思路分析与步骤:首先先处理:如果树是空树root,如果只有一个root结点,则等价将二叉树置空
1.因为二叉树是单向的,所以判断当前的子节点是否需要要删除结点,而不能去判断当前这个结点是不是需要删除结点
2.如果当前结点的左子结点不为空,并且左子结点就是要删除结点,就将this.left =null;并且返回(结束递归删除)
3.如果当前结点的右子结点不为空,并且右子结点就是要删除结点,就将this.right=null;并且就返回
4.如第二步和第三步没有删除结点,需要向左子树进行递归删除
5.如果第四步没有删除结点,应当向右子树进行递归删除

顺序存储二叉树
从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。
特点：1.顺序二叉树只考虑完全二叉树。2.第n个元素的左子结点为2*n+1.3.第n个元素的右子结点为2*n+2  4.第n个元素的父节点为(n-1)/2.
5.n:表示二叉树中第几个元素

线索化二叉树
1.n个结点的二叉链表中含有n+1[公式2n-(n-1)=n+1]个空指针域.利用二叉链表中的空指针域,存放指向该结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为线索)
2.这种加上了线索的二叉链表称为线索链表,相应的二叉树称为线索二叉树,根据线索性质的不同,线索二叉树可分为前序线索二叉树,中序线索二叉树和后序线索二叉树三种
3.一个结点的前一个结点,称为前驱结点
4.一个结点的后一个结点,称为后继结点
说明:当线性化二叉树后,Node结点的属性left和right,有以下情况:1.left指向的是左子树,也可能是指向的前驱结点.
2.right指向的是右子树,也可能是指向后继结点
遍历线索化二叉树
因为线索化后,各个结点指向有变化,因此原来的遍历方式不能使用,各个结点可以通过线性方式遍历,无需使用递归方式,提高了遍历的效率,遍历的次序和中序遍历保持一致

树机构实际应用
堆排序
1.堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度为O(nlogn),它也是不稳定排序
2.堆是具有以下性质的完全二叉树:每个结点的值大于或等于左右孩子结点的值,称为大顶堆.注意:没有要求结点的左孩子的值和右孩子的值的大小关系
3.每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆
大顶堆特点:arr[i]>=arr[2*i+1]&&arr[i] >=arr[2*i+2]//i对应第几个结点,i从0开始编号
小顶堆特点:arr[i]<=arr[2*i+1] &&arr[i]<=arr[2*i+2]//i对应第几个结点,i从0开始编号
6.一般升序采用大顶堆,降序采用小顶堆
堆排序基本思想:
1.将待排序序列构造成一个大顶堆
2.整个序列的最大值就是堆顶的根节点
3.将其与末尾元素进行交换,此时末尾就为最大值...
4.将剩余n-1个元素重新构造成一个堆,这样会得到n个元素的次小值,如此反复执行,就能得到一个有序性序列.
总结:1.将无序序列构造成一个堆,根据升序降序需求选择大顶堆或小顶堆2.将堆顶元素与末尾元素交换,将最大元素沉到数组末端.3.重新调整结构,使其满足堆定义,继续交换堆顶元素与当前末尾元素,反复执行调整加交换步骤,直到整个序列有序

赫夫曼树
1.给定n个权值作为n个叶子结点,构造一颗二叉树,若树的带权路径长度wpl达到最小,这样的二叉树为最优二叉树,也称为哈夫曼树
2.赫夫曼树时带权路径长度最短的树,权值较大的结点离根较近
概念:1路径和路径长度:在一棵树下,从一个结点往下可以达到孩子或孙子结点之间的通路,称为路径.通路中分支的数目为路径长度.若规定根节点的层数为1,则从根节点到第L层结点的路径长度为L-1
2.结点的权及带权路径长度:若将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权.结点的带权路径长度为:从根结点到该结点之间的路径长度与该结点的权的乘积
3.树的带权路径长度:树的带权路径长度规定为所有叶子结点的带权路径长度之和,记为WPL.权值越大的结点离根节点越近的二叉树才是最优二叉树.
4.WPL最小的就是赫夫曼树.
构成赫夫曼树的思路:1.从小到大排序,将每一个结点,每个数据都是一个结点,每个结点可以看成是一颗最简单的二叉树
2.取出根节点权值最小的两颗二叉树
3.组成一颗新的二叉树,将该新的二叉树的根节点的权值是前面两颗二叉树结点权值的和
4.再将这颗新的二叉树,以根结点的权值大小再次排序,不断重复1-2-3-4的步骤,直到数列中,所有的数据都被处理,就得到一颗赫夫曼树

赫夫曼编码
1.赫夫曼编码是一种编码方式，属于一种程序算法。
2.赫夫曼编码广泛用于数据文件压缩，通常压缩率在20到90之间
3.赫夫曼吗是可变子长编码VLC的一种
思路：1.将传输的字符串按字符出现的次数构建成一颗赫夫曼树，次数作为权值。2.根据赫夫曼树，给各个字符规定编码，向左的路径为0，向右的路径为1。此编码满足前缀编码，即字符的编码不能是其他字符编码的前缀。不会造成匹配的多义性
构建赫夫曼树的步骤：
1.从小到大排序，将每一个数据，每个数据就是一个结点，每个结点可以看成是一颗最简单的二叉树
2.取出根节点权值最小的两颗二叉树
3.组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
4.再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有数据被处理，就得到一颗赫夫曼树
注意事项：赫夫曼树根据排序方法不同，对应的赫夫曼编码也不完全一样。但是wpl是一样的，都是最小的，生成的赫夫曼长度也是一样的
赫夫曼编码压缩文件注意事项:1.如果文件本身是经过压缩处理的,那么使用赫夫曼编码再压缩效率不会有明显变化.
2.赫夫曼编码是按字节来处理的,可以处理所有的文件
3,如果一个文件汇总的内容,重复的数据不多,压缩的效果也不会很明显

二叉排序树
二叉排序树：BST，对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大
PS:如果有相同的值，可以将该节点放在右子节点或左子节点
二叉排序树的创建和遍历：看代码
二叉排序树的删除分为三种情况：
1.删除叶子节点：（1）需要先去找到要删除的节点targetNode（2）找到target的父节点parent(3)确定target是parent的左子节点还是右子节点(4)根据前面情况来删除左子节点parent.left=null,右子节点parent.right=null
2.删除只有一节子树的节点:(1)先去找到要删除的节点targetNode(2)找到targetNode的父节点parent(3)确定targetNode的子节点是左子节点还是右子节点(4)targetNode是parent的左子节点还是右子节点
(5)如果targetNode有左子节点1.如果是target是parent的左子节点parent.left=targetNode.left;2.如果targetNode是parent的右子节点parent.right=targetNode.left;
(6)如果targetNode有右子节点1.如果targetNode是parent的左子节点parent.left=targetNode.right.2.如果targetNode是parent的右子节点,parent.right=targetNode.right
3.删除两颗子树的节点(1)先去找到要删除的节点targetNode(2)找到targetNode的父节点parent(3)从targetNode的右子树找到最小的节点(4)用一个临时变量,嫁给你最小节点的值保存在temp=11
(5)删除该最小节点(5)targetNode.value=temp;

平衡二叉树
平衡二叉树也叫平衡二叉搜索树，可以保证查询效率很高。
特点：它是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。平衡二叉树实现方法有红黑树,avl,替罪羊树等
左旋转思路:1.创建一个新的节点newNode,值等于当前根节点的值
2.把新节点的左子树设置当前节点的左子树newNode.left=left
3.把新节点的右子树设置为当前节点的右子树的左子树 newNode.right=right.left;
4.把当前节点的值换为右子节点的值 value=right.value
5.把当前节点的右子树设置成右子树的右子树 right=right.right
6.把当前节点的左子树设置为新节点 left=newleft;
右旋转思路:1.创建一个新的节点newNode,值等于当前根节点的值.
2.把新节点的左子树设置当前节点的左子树的右子树newNode.right=right
3.把新节点的左子树设置为当前节点的左子树的右子树newNode.left=left.right
4.把当前节点的值换为左子节点的值value =left.value
5.把当前节点的左子树设置成左子树的左子树left=left.left
6.把当前节点的右子树设置为新节点 right=newLeft;
双旋转的思路分:1.当符合右旋转的条件时
2.如果他的左子树的右子树高度大于他的左子树的高度
3.先对当前这个节点的左节点进行左旋转
4.在对当前节点进行右旋转的操作

多路查找树
二叉树的问题分析：1.二叉树需要加载到内存的，如果二叉树的节点很多，就会存在以下问题：1.在构建二叉树时，需要多次进行io操作，速度有影响。2.节点海量，会降低操作速度

多叉树
在二叉树中，每个节点有数据项，最多有两个子节点，如果允许每个节点有更多的数据项和更多的子节点，就是多叉树
多叉树通过重新组织节点，减少树的高度，对二叉树进行优化

B树
B树通过重新组织节点，降低树的高度，并且减少IO读写次数来提升效率。

2-3树
1.2-3树的所有叶子节点都在同一层(只要B树都满足这个条件)
2.有两个子节点的节点叫做二节点,二节点要么没有子节点,要么有两个子节点
3.有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点
4.2-3树是由二节点和三节点构成的树
2-3树的插入规则:1.2-3树的所有叶子节点都在同一层.2.有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点.3.有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点
4.当按照规则插入一个数到某个节点时,不能满足上面三个要求,就需要拆,先向上拆,如果上层满,则拆本层,拆后需要满足上面3个条件.5.对于三节点的子树的值大小仍然遵守(BST二叉排序树)的规则
除了23树,还有234树等,概念和23树类似,也是一种B树

B树
B树的介绍:
1.B树的阶:节点的最多子节点的个数.
2.B树的搜索,从根节点开始,对节点内的关键字有序序列进行二分查找,如果命中则结束,否则进入查询关键字所属范围的儿子节点;重复,直到所对应的儿子指针为空,或已经是叶子节点
3.关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据
4.搜索有可能在非叶子节点结束
5.其搜索性能等价于在关键字全集内做一次二分查找

B+树的介绍
B+树是B树的变体,也是一种多路搜索树
1.B+树的搜索与B树基本相同,区别时B+树只有达到叶子节点才命中(B树可以在非叶子节点命中),其性能也等价于在关键字全集做一次二分查找
2.所有关键字都出现在叶子节点的链表(即数据只能在叶子节点),且链表中的关键字恰好时有序的
3.不可能在非叶子节点命中
4.非叶子节点相当于是叶子节点的索引,叶子节点相当于是存储关键字数据的数据层
5.更适合文件索引系统
6.B树和B+树有自己的应用场景.

B*树的介绍
B*树是B+树的变体,在B+树的非根和非叶子节点再增加指向兄弟的指针
B*的说明:
1.B*树定义了非叶子节点关键子个数至少为(2/3)*M,即块的最低使用率为2/3,而B+树的快的最低使用率为1/2
2.B*树分配新节点的概率比B+树要低,空间使用率更高

图
图是一种数据结构,其中节点可以具有零个或多个相邻元素,两个节点之间的连接称为边,节点也可以称为顶点.
图的常用概念:1.顶点.2.边.3.路径. 4.无向图:顶点之间的连接没有方向 5.有向图:顶点之间的连接有方向 6.带权图:边带权值的图也叫网
图的表示方式
图的表示方式有两种:二维数组(领接矩阵);链表表示领接表
领接矩阵
领接矩阵是表示图形中顶点之间相邻关系的矩阵,对于n个顶点的图而言,矩阵是row和col表示的是1...n个点
领接表
1.领接矩阵需要为每个顶点都分配n个边的空间,其实有很多边都不存在,会造成空间的一定损失
2.领接表的实现只关心存在的边,不关心不存在的边,因此没有空间浪费,领接表由数组+链表组成

图的深度优先遍历
图遍历的介绍
所谓图的遍历,即是对节点的访问.一个图遍历节点有两种方法:1.深度优先遍历 2.广度优先遍历
深度优先遍历思想
1.深度优先遍历,从初始节点出发,初始访问节点可能有多个领接节点,深度优先遍历的策略是首先访问第一个领接节点,然后再以这个被访问节点的领接节点作为初始节点,访问它的第一个领接节点,相当于每次都在访问完当前节点后首先访问当前节点的第一个领接节点
2.深度搜索是一个递归的过程
算法步骤
1.访问初始节点v,并标记节点v为已访问
2.查找节点v的第一个领接节点w
3.若w存在,则继续执行4,如果w不存在,就返回到第一步,从v的下一个节点继续
4.若w未被访问,对w进行深度优先遍历递归(把w当作另一个w,进行步骤123)
5.查找节点v的w领接节点的下一个领接节点,转到步骤3

图的广度优先遍历
思想:类似于一个分层搜索的过程,广度优先遍历需要使用一个队列保持访问过的节点的顺序,以便按这个顺序来访问节点的领接节点
算法步骤:
1.访问初始节点v并标记节点v为以访问
2.节点v入队列
3.当队列非空时,继续执行,否则算法结束
4.出队列,取得队头节点u
5.查找节点u的第一个领节点w
5.若节点u的领接节点w不存在,则转到步骤3,否则循环执行以下三个步骤:1.若节点w尚未被访问,则访问节点w并标记为访问2.节点w入队列3.查找节点u的继w领接节点后的下一个领接节点w,转到步骤6














Damn it!fuCK Github THIS connection!~