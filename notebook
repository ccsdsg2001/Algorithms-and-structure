数据结构和算法
程序=数据结构+算法。数据结构是算法的基础。
数据结构：线性结构和非线性结构。线性结构：最常用的数据结构，特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表成为顺序表，其存储元素是连续的。链式存储的线性表为链表。其存储元素不一定连续。
线性结构常见的有：数组，队列，链表和栈。

稀疏数组
很多没有意义的数组——稀疏数组
处理方法是：记录数组一共有几行几列，有多少个不同的值。把具有不同值的元素的行列和值记录在一个小规模的数组中，从而缩小程序的规模。
二维数组 转 稀疏数组的思路
1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组
稀疏数组转原始的二维数组的思路
1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

队列
队列是一个有序表，可以用数组或链表来实现
遵循先入先出的原则，先存入队列的数据，要先取出，后存入的要后取出
数组模拟队列。队列本事是有序表，用maxsize表示该队列最大容量。因为队列的输出，输入分别是从前后端来处理，需要两个表量front和rear分别记录队列前后端的下标，front随着数据输出而改变。而rear随着数据输入而改变
思路分析：当我们将数据存入队列称”addqueue“,需要两个步骤
1：将尾指针往后移：rear+1，当front==rear【空】
2：若尾指针rear小于队列最大小标maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxsize-1【队列满】
问题分析：数组使用一次就不能使用，没有达到复用的效果。2.将这个数组使用算法，改进成一个环形数组
数组模拟环形队列
为充分利用数组，将数组看作一个环形（通过取模方式来实现）
分析说明：1尾索引的下一个头为索引时表示队列满，即将队列容量空出一个，在做判断队列满时候注意（rear+1）%maxsize==front满。2.rear ==front[空]
思路：1 front变量的含义调整：front指向队列中的第一个元素，arr[front]就是队列的第一个元素front初始值=0.
2.rear指向队列的最后一个元素的后一个位置，空出一个空间作为约定，rear初始值=0
3.当队列满时，（rear+1）%maxsize=front【满】
4.队列为空的条件，rear==front(空)
5.队列中有效的数据个数(rear+maxsize-front)%maxsize //rear =1 front =0。可以在原来基础上修改得到一个环形队列

链表
1.链表是有序的列表，链表以节点的方式来存储，是链式存储。2.每个节点包含data域，next域：指向下一个节点。3.链表的各个节点不一定是连续存储。4.链表分带头节点的链表和没有头节点的链表
，根据需求来确定
思路分析：添加（创建）1.先创建一个head头节点，作用就是表示单链表的头。2.后面我们每添加一个节点，直接加入到链表的最后。遍历：1.通过一个辅助变量去遍历，帮助遍历整个链表
如需要按照编号的顺序添加，思路：1首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定。2.新的节点.next=temp.next 3.将temp.next= 新的节点
3.修改节点功能：（1）先找到该节点，通过遍历（2）temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname
4.删除节点 （1）先找到需要删除这个节点的前一个节点temp。（2）temp.next =temp.next.next (3)被删除节点不会有其他引向，被垃圾回收机制回收
求单链表中有效节点的个数
/*方法：找到单链表节点的个数
* head 链表的头节点
* return 返回的就是有效节点的个数*/
查找单链表中的倒数第K个节点
/*思路
* 1.编写一个方法，接受head节点，同时接受一个index
* 2.index表示是倒数第index个节点
* 3.先从链表从头到尾遍历，得到链表总长度getlength
* 4.得到size后，从链表中第一个开始遍历(size-index)个，就可以得到
* 5.如找到就返回节点，否则就返回null*/
单链表的反转
思路：1.先定义一个节点reverserhead =new Heronode（）
    * 2.从头遍历到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reversehead的最前端
    * 3原来的链表head.next =reverseHead.next*/
从头到尾打印单链表
思路分析：1.逆序打印单链表。2、方式1：先将单链表进行反转操作，然后在遍历，缺点就是会破坏原来单链表结构，不建议。方法2：可以利用栈的数据结构，将各个节点压入栈中，利用栈的先进先出的特点，实现逆序打印的结果

双向链表分析
单向链表的缺点分析：
1).单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。2).单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除，单链表删除节点时，需要temp，temp总是删除节点的前一个节点
思路分析：1）遍历：和单链表一样，只是可以向前，也可以向后查找。2）.添加：默认添加到双向链表的最后，（1）先找到双向链表的最后节点。（2）temp.next = newHeroNode (3)newHeroNode.pre = temp;
3).修改：思路和单向链表一样。4）.删除：(1)因为是双向链表，可以实现自我删除某个节点。（2）直接找到要删除节点如temp（3）temp.pre.next = temp.next (4)temp.next.pre =temp.pre;

单向环形链表
Josephu约瑟夫问题：设编号为1，2，~~~n的n个人围坐一圈，约定编号为K的人从1开始报数，数到M的那个人出列，他的下一位又从1开始报数，数到m的那个人有出列，直到所有人出列为止，从而产生一个出队编号的序列
提示：用一个不带头节点的循环链表来处理约瑟夫问题：先构成一个由N个节点的单循环链表，由K结点从1开始计数，计到M时，对应节点从链表中删除，在从被删除节点的下一个节点从1开始计数，直到最后一个节点从链表中删除算法结束
创建环形链表思路：构建一个单向的环形链表：（1）先创建第一个节点，让first指向该节点，并形成环形。（2）后面当我们创建一个新的节点，把节点加入到已有的环形链表即可
遍历环形链表：1.先让一个辅助指针（变量）curBoy，指向first节点。2.通过一个whule循环遍历环形链表即可curBoy.next== first 即可
环形链表出队列思路分析:1.需要创建一个辅助指针（变量）helper，事先指向环形链表的最后这个节点。2，先让first和helper移动k-1次，然后让first和helper指针同时移动m-1次。3.将first指向节点出列，first=first.next,helper.next=first.原来
first指向的节点没有任何引用，就会被回收。

栈
栈是一个先入后出的有序列表。
栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表，允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底。
最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素相反，最后放入元素最先删除，最先放入元素最后删除。
栈的应用场景
1.子程序的调用:在跳往子程序前,将下个指令的地址存到堆栈中,直到子程序执行完再将地址取出,以回到原来程序中.
2.处理递归调用:存储下一个指令地址,将参数,区域变量等数据存入堆栈中.
3.表达式的转换(中缀表达式和后缀表达式)与求值
4.二叉树的遍历
5.图形的深度优先算法
实现栈的思路分析
1.使用数组来模拟栈
2.定义一个top来表示栈,初始化为-1
3.入栈的操作,当有数据加入到栈时,top++;stack[top] = data;
4.出栈的操作:int value =stack[top];top--;return value

栈实现综合计算器（中缀表达式）
使用栈完成表达式的计算思路
1.通过一个index值（索引），来遍历表达式
2.如发现是一个数字，则直接入数栈
3.如是一个符号，则：（1）如当前的符号栈为空，则直接入栈。（2）如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个数，在符号栈中pop出一个符号，进行运算，
将得到的结果，入数栈，将当前的操作符入符号栈，如果当前的操作符的优先级高于栈中的操作符，就直接入符号栈
4.当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
5.最后在数栈中只有一个数字，就是表达式的结果
前缀表达式
前缀表达式又称波兰式。前缀表达式的运算符位于操作数之前。
前缀表达式的求值
从右到左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈。重复上述过程直到表达式最左端，最后运算得出的值为表达式的结果
例如（3+4）*5-6对应前缀表达式是-*+3 4 5 6，步骤如下：
1.从右到左扫描，将6.5.4.3压入堆栈
2.遇到+运算符，弹出3和4，计算出3+4的值，得7，再将7入栈。
3.接下来*运算符，弹出7和5，计算7*5等于35，将35入栈
4.最后是-运算符，计算出35-6得值，由此得出最终结果
中缀表达式
中缀表达式就是常见的运算表达式。
后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后。
后缀表达式的计算机求值
从左到右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈。重复上述过程直到表达式的最右端，最后运算出结果就是表达式的结果
例：（3+4）*5-6对应的前缀表达式就似乎34+5*6—，步骤如下：
1 从左到右扫描，将3和4压入堆栈
2 遇到+运算符，弹出4和3，计算出3+4的值，得7，再将7入栈
3 将5入栈
4 接下来*运算符，弹出5和7，计算出7*5=35，将35入栈
5 将6入栈
6 最后-运算符，计算出35-6值，得出29最终结果
中缀表达式转换为后缀表达式
具体步骤：
1.初始化两个栈:运算符栈s1和存储中间的结果栈s2
2.从左到右扫描中缀表达式
3.遇到操作数时,将其压s2
4.遇到运算符时,比较与s1栈顶的运算符的优先级:(1)如果s1为空,或栈顶运算符为左括号"(",则直接将此运算符入栈.(2)否则,若优先级比栈顶运算符高,将运算符压入s1.(3)否则,将s1栈顶的运算符弹出并压入到s2中,再次转到(4-1)与s1中新的
栈顶运算符相比较
5.遇到括号时:1.如果是左括号"(",则直接压入到s1.(2)如果是右括号")",则依次弹出s1栈顶的运算符,并压入s2,直到遇到左括号位置,此时将这一对括号丢弃
6.重复步骤2到5,直到表达式的最右边.
7.将s1中剩余的运算符依次弹出并压入s2
8.依次弹出s2中的元素并输出,结果的逆序为中缀表达式对应的后缀表示式

递归
递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以使代码变得简洁
两个案例解释递归调用机制：打印问题，阶乘问题
递归解决什么问题:数学问题,各种算法中也会使用到递归,常用栈解决的问题.
递归时需要遵守的重要规则:
1.执行一个方法时,创建一个新的受保护的独立空间(栈空间)
2.方法的局部变量是独立的,不会相互影响,比如n变量
3.如果方法中使用的是引用类型变量,就会共享该引用类型的数据
4.递归必须向推出递归的条件逼近,否则就是无限递归,出现StackOverflowError
5.当一个方法执行完毕.或者遇到return,就会返回,遵守谁调用,就将结果返回给谁,同时当方法执行完毕或者返回时,该方法也执行完毕
递归—八皇后问题（回溯算法）
在8*8的国际象棋上摆放8个皇后，任意两个皇后不能处于同一行或同一列或同一斜线上，问有多少中摆法
问题算法思路分析
1.第一个皇后先放第一行第一列
2.第二个皇后放在第二行第一列，判断是否ok，如果不，继续放在第二列，第三列，依次把所有列放完，找到一个合适
3.继续第三个皇后，还是第一列，第二列~直到第8个皇后放在一个不冲突的为止，算找到了一个正确的解
4.当得到第一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到
5.然后回头继续第一个皇后放第二列，后面继续执行1，2，3，4的步骤
理论上应该创建二维数组来表示棋盘，但可以通过算法，用一个一维数组可解决问题。arr[8]={0，4，7，5，2，6，1，3}//对应arr下标,表示第几行,第几个皇后,arr[i]=val,val表示第i+1个皇后,放在第i+1行的第val+1列.

排序算法
排序也称排序算法，排序是将一组数据，以指定的顺序进行排列的过程。
排序的分类：1.内部排序：将需要处理的所有数据加载到内部存储器（内存）中进行排序。2.外部排序法:数据量过大,无法全部加载到内存中,需要借助外部存储(文件等)进行排序.3.常见排序算法分类:直接插入排序,希尔排序,简单选择排序,堆排序,冒泡排序,快速排序,归并排序,基数排序
算法时间复杂度
度量一个程序执行时间方法:1.事后统计方法:要在同一台计算机的相同状态下运行,才能比较那个算法速度更快.2.事前估算的方法:分析某个算法时间复杂度判断哪个算法更优
时间频度:一个算法花费的时间与算法中语句中执行的次数成比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n).
当n足够大时,可忽略常数项,忽略低次项,忽略系数
时间复杂度
1.一般情况下,算法中的基本操作语句的重复执行次数是问题规模n的某个系数,用T(n)表示,若有某个辅助函数f(n)使得n趋近于无穷大时,T(n)/f(n)的极限值不等于0的常熟,则称f(n)是T(n)的同数量级函数,记作T(n)=O(f(n)),称O(f(n))为算法的渐进时间复杂度,简称时间复杂度
2.T(n)不同,但时间复杂度可能相同
3.计算时间复杂度的方法:用常数1代替运行时间中的所有加法常数,修改后的运行次数函数中,只保留最高阶项,去掉最高阶项的系数
常见的时间复杂度
1.常数阶O(1) 2.对数阶O(log2n) 3.线性阶O(n) 4.线性对数阶O(nlog2n) 5.平方阶O(n^2) 6.立方阶O(n^3) 7.K次方阶O(n^K) 8.指数阶O(2^n)
Ps:常见的算法时间复杂度由小到大为O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(n^3)<O(n^K)<O(2^n),随着问题规模N的不断增大,时间复杂度不断增大,算法执行效率越低.避免使用指数阶的算法

1)常数阶O(1) 没有循环等复杂结构,时间复杂度就是O(1) ex:int i =1; int j =2; int m =i+j;上述代码再执行的时候,消耗的时候并不随着某个变量的增长而增长,用O(1)来表示它的时间复杂度
2)对数阶O(log2N) int i=1;while(i<n){i = i*2} 在循环里面,将I乘以2,之后I距离n就越来越近,假设循环x次之后,i就大于2,循环就退出了.时间复杂度为:O(log2n),O(log2n)的这个2时间上根据代码变化,i=i*3,则是O(log3n)
3)线性阶O(n)for(int i=1;i<=n;i++){j = i;j++} for循环里面的代码执行n遍,消耗的时间随着n的变化而变化的,可以用O(n)表示它的时间复杂度
4)线性对数阶O(nlogn) for(m=1;m<n;m++){i =1;while(i<n){i =i*2;}} 将时间复杂度O(logn)的代码循环N遍,时间复杂度就是N*O(logN)
5)平方阶O(n^2) for(x=1;i<=n;x++){for(x=1;i<=n;i++{j=i;j++}} 把O(n)代码嵌套循环一遍,时间复杂度就是O(n2),将其中一层循环n改成m,就是O(m*n)
平时时间复杂度和最坏时间复杂度
1)平均时间复杂度是所有可能的输入实例均以等概率出现的情况下,该算法的运行时间
2)最坏情况下的时间复杂度称最坏时间复杂度,一般时间复杂度是最坏情况下的时间复杂度,因为最坏情况下的时间复杂度是算法在如何输入实例上运行时间上的界限,保证了算法运行时间不会比最坏情况更长
3)平均时间复杂度和最坏时间复杂度;除shell排序和快排不一致,其他都一致
冒泡排序O(n^2) 交换排序O(n^2) 选择排序O(n^2) 插入排序O(n^2) 基数排序O(logR B) shell排序平均O(nlogN) 最差情形O(n^s) 1<s<2  快速排序O(nlogn) 最差O(n^2) 归并排序O(nlogn) 堆排序O(nlogn)
算法空间复杂度
一个算法的空间复杂度定义为该算法所耗费的存储空间.空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度,有的算法需要占用临时工作单元与解决问题规模n有关,随着n增大而增大,当n较大时,占用更多的存储单元.
从用户使用体验上看,更看重程序的执行速度,本质就是用空间换时间

冒泡排序
思路：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部。
优化：在排序过程中，各元素不断接近自己的位置，如一趟比较下俩没有进行过交换，说明序列有序，在排序过程中设置一个标志flag判断元素是否发生交换，从而减少不必呀的比较。
原始数组：{3，9，-1，10，20} 过程：1，一共进行数组的大小-1次大的循环。2. 每一样排序的次数在逐渐的减少。3.如在某趟排序中，没有发生一次交换，可以提前结束排序，这个就是优化.




































