数据结构和算法
程序=数据结构+算法。数据结构是算法的基础。
数据结构：线性结构和非线性结构。线性结构：最常用的数据结构，特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表成为顺序表，其存储元素是连续的。链式存储的线性表为链表。其存储元素不一定连续。
线性结构常见的有：数组，队列，链表和栈。

稀疏数组
很多没有意义的数组——稀疏数组
处理方法是：记录数组一共有几行几列，有多少个不同的值。把具有不同值的元素的行列和值记录在一个小规模的数组中，从而缩小程序的规模。
二维数组 转 稀疏数组的思路
1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组
稀疏数组转原始的二维数组的思路
1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

队列
队列是一个有序表，可以用数组或链表来实现
遵循先入先出的原则，先存入队列的数据，要先取出，后存入的要后取出
数组模拟队列。队列本事是有序表，用maxsize表示该队列最大容量。因为队列的输出，输入分别是从前后端来处理，需要两个表量front和rear分别记录队列前后端的下标，front随着数据输出而改变。而rear随着数据输入而改变
思路分析：当我们将数据存入队列称”addqueue“,需要两个步骤
1：将尾指针往后移：rear+1，当front==rear【空】
2：若尾指针rear小于队列最大小标maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxsize-1【队列满】
问题分析：数组使用一次就不能使用，没有达到复用的效果。2.将这个数组使用算法，改进成一个环形数组
数组模拟环形队列
为充分利用数组，将数组看作一个环形（通过取模方式来实现）
分析说明：1尾索引的下一个头为索引时表示队列满，即将队列容量空出一个，在做判断队列满时候注意（rear+1）%maxsize==front满。2.rear ==front[空]
思路：1 front变量的含义调整：front指向队列中的第一个元素，arr[front]就是队列的第一个元素front初始值=0.
2.rear指向队列的最后一个元素的后一个位置，空出一个空间作为约定，rear初始值=0
3.当队列满时，（rear+1）%maxsize=front【满】
4.队列为空的条件，rear==front(空)
5.队列中有效的数据个数(rear+maxsize-front)%maxsize //rear =1 front =0。可以在原来基础上修改得到一个环形队列

链表
1.链表是有序的列表，链表以节点的方式来存储，是链式存储。2.每个节点包含data域，next域：指向下一个节点。3.链表的各个节点不一定是连续存储。4.链表分带头节点的链表和没有头节点的链表
，根据需求来确定
思路分析：添加（创建）1.先创建一个head头节点，作用就是表示单链表的头。2.后面我们每添加一个节点，直接加入到链表的最后。遍历：1.通过一个辅助变量去遍历，帮助遍历整个链表
如需要按照编号的顺序添加，思路：1首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定。2.新的节点.next=temp.next 3.将temp.next= 新的节点
3.修改节点功能：（1）先找到该节点，通过遍历（2）temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname
4.删除节点 （1）先找到需要删除这个节点的前一个节点temp。（2）temp.next =temp.next.next (3)被删除节点不会有其他引向，被垃圾回收机制回收